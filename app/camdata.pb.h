// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camdata.proto

#ifndef PROTOBUF_INCLUDED_camdata_2eproto
#define PROTOBUF_INCLUDED_camdata_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_camdata_2eproto 

namespace protobuf_camdata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_camdata_2eproto
namespace target_cam {
class target_data;
class target_dataDefaultTypeInternal;
extern target_dataDefaultTypeInternal _target_data_default_instance_;
}  // namespace target_cam
namespace google {
namespace protobuf {
template<> ::target_cam::target_data* Arena::CreateMaybeMessage<::target_cam::target_data>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace target_cam {

// ===================================================================

class target_data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:target_cam.target_data) */ {
 public:
  target_data();
  virtual ~target_data();

  target_data(const target_data& from);

  inline target_data& operator=(const target_data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  target_data(target_data&& from) noexcept
    : target_data() {
    *this = ::std::move(from);
  }

  inline target_data& operator=(target_data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const target_data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const target_data* internal_default_instance() {
    return reinterpret_cast<const target_data*>(
               &_target_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(target_data* other);
  friend void swap(target_data& a, target_data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline target_data* New() const final {
    return CreateMaybeMessage<target_data>(NULL);
  }

  target_data* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<target_data>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const target_data& from);
  void MergeFrom(const target_data& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(target_data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes img = 3;
  bool has_img() const;
  void clear_img();
  static const int kImgFieldNumber = 3;
  const ::std::string& img() const;
  void set_img(const ::std::string& value);
  #if LANG_CXX11
  void set_img(::std::string&& value);
  #endif
  void set_img(const char* value);
  void set_img(const void* value, size_t size);
  ::std::string* mutable_img();
  ::std::string* release_img();
  void set_allocated_img(::std::string* img);

  // optional string lat = 4;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 4;
  const ::std::string& lat() const;
  void set_lat(const ::std::string& value);
  #if LANG_CXX11
  void set_lat(::std::string&& value);
  #endif
  void set_lat(const char* value);
  void set_lat(const char* value, size_t size);
  ::std::string* mutable_lat();
  ::std::string* release_lat();
  void set_allocated_lat(::std::string* lat);

  // optional string long = 5;
  bool has_long_() const;
  void clear_long_();
  static const int kLongFieldNumber = 5;
  const ::std::string& long_() const;
  void set_long_(const ::std::string& value);
  #if LANG_CXX11
  void set_long_(::std::string&& value);
  #endif
  void set_long_(const char* value);
  void set_long_(const char* value, size_t size);
  ::std::string* mutable_long_();
  ::std::string* release_long_();
  void set_allocated_long_(::std::string* long_);

  // required int32 seq = 2;
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 2;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:target_cam.target_data)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_seq();
  void clear_has_seq();
  void set_has_img();
  void clear_has_img();
  void set_has_lat();
  void clear_has_lat();
  void set_has_long_();
  void clear_has_long_();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr img_;
  ::google::protobuf::internal::ArenaStringPtr lat_;
  ::google::protobuf::internal::ArenaStringPtr long__;
  ::google::protobuf::int32 seq_;
  friend struct ::protobuf_camdata_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// target_data

// required string name = 1;
inline bool target_data::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void target_data::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void target_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void target_data::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& target_data::name() const {
  // @@protoc_insertion_point(field_get:target_cam.target_data.name)
  return name_.GetNoArena();
}
inline void target_data::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:target_cam.target_data.name)
}
#if LANG_CXX11
inline void target_data::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:target_cam.target_data.name)
}
#endif
inline void target_data::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:target_cam.target_data.name)
}
inline void target_data::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:target_cam.target_data.name)
}
inline ::std::string* target_data::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:target_cam.target_data.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* target_data::release_name() {
  // @@protoc_insertion_point(field_release:target_cam.target_data.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void target_data::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:target_cam.target_data.name)
}

// required int32 seq = 2;
inline bool target_data::has_seq() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void target_data::set_has_seq() {
  _has_bits_[0] |= 0x00000010u;
}
inline void target_data::clear_has_seq() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void target_data::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 target_data::seq() const {
  // @@protoc_insertion_point(field_get:target_cam.target_data.seq)
  return seq_;
}
inline void target_data::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:target_cam.target_data.seq)
}

// optional bytes img = 3;
inline bool target_data::has_img() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void target_data::set_has_img() {
  _has_bits_[0] |= 0x00000002u;
}
inline void target_data::clear_has_img() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void target_data::clear_img() {
  img_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_img();
}
inline const ::std::string& target_data::img() const {
  // @@protoc_insertion_point(field_get:target_cam.target_data.img)
  return img_.GetNoArena();
}
inline void target_data::set_img(const ::std::string& value) {
  set_has_img();
  img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:target_cam.target_data.img)
}
#if LANG_CXX11
inline void target_data::set_img(::std::string&& value) {
  set_has_img();
  img_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:target_cam.target_data.img)
}
#endif
inline void target_data::set_img(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_img();
  img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:target_cam.target_data.img)
}
inline void target_data::set_img(const void* value, size_t size) {
  set_has_img();
  img_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:target_cam.target_data.img)
}
inline ::std::string* target_data::mutable_img() {
  set_has_img();
  // @@protoc_insertion_point(field_mutable:target_cam.target_data.img)
  return img_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* target_data::release_img() {
  // @@protoc_insertion_point(field_release:target_cam.target_data.img)
  if (!has_img()) {
    return NULL;
  }
  clear_has_img();
  return img_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void target_data::set_allocated_img(::std::string* img) {
  if (img != NULL) {
    set_has_img();
  } else {
    clear_has_img();
  }
  img_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), img);
  // @@protoc_insertion_point(field_set_allocated:target_cam.target_data.img)
}

// optional string lat = 4;
inline bool target_data::has_lat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void target_data::set_has_lat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void target_data::clear_has_lat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void target_data::clear_lat() {
  lat_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lat();
}
inline const ::std::string& target_data::lat() const {
  // @@protoc_insertion_point(field_get:target_cam.target_data.lat)
  return lat_.GetNoArena();
}
inline void target_data::set_lat(const ::std::string& value) {
  set_has_lat();
  lat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:target_cam.target_data.lat)
}
#if LANG_CXX11
inline void target_data::set_lat(::std::string&& value) {
  set_has_lat();
  lat_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:target_cam.target_data.lat)
}
#endif
inline void target_data::set_lat(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lat();
  lat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:target_cam.target_data.lat)
}
inline void target_data::set_lat(const char* value, size_t size) {
  set_has_lat();
  lat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:target_cam.target_data.lat)
}
inline ::std::string* target_data::mutable_lat() {
  set_has_lat();
  // @@protoc_insertion_point(field_mutable:target_cam.target_data.lat)
  return lat_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* target_data::release_lat() {
  // @@protoc_insertion_point(field_release:target_cam.target_data.lat)
  if (!has_lat()) {
    return NULL;
  }
  clear_has_lat();
  return lat_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void target_data::set_allocated_lat(::std::string* lat) {
  if (lat != NULL) {
    set_has_lat();
  } else {
    clear_has_lat();
  }
  lat_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lat);
  // @@protoc_insertion_point(field_set_allocated:target_cam.target_data.lat)
}

// optional string long = 5;
inline bool target_data::has_long_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void target_data::set_has_long_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void target_data::clear_has_long_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void target_data::clear_long_() {
  long__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_long_();
}
inline const ::std::string& target_data::long_() const {
  // @@protoc_insertion_point(field_get:target_cam.target_data.long)
  return long__.GetNoArena();
}
inline void target_data::set_long_(const ::std::string& value) {
  set_has_long_();
  long__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:target_cam.target_data.long)
}
#if LANG_CXX11
inline void target_data::set_long_(::std::string&& value) {
  set_has_long_();
  long__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:target_cam.target_data.long)
}
#endif
inline void target_data::set_long_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_long_();
  long__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:target_cam.target_data.long)
}
inline void target_data::set_long_(const char* value, size_t size) {
  set_has_long_();
  long__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:target_cam.target_data.long)
}
inline ::std::string* target_data::mutable_long_() {
  set_has_long_();
  // @@protoc_insertion_point(field_mutable:target_cam.target_data.long)
  return long__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* target_data::release_long_() {
  // @@protoc_insertion_point(field_release:target_cam.target_data.long)
  if (!has_long_()) {
    return NULL;
  }
  clear_has_long_();
  return long__.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void target_data::set_allocated_long_(::std::string* long_) {
  if (long_ != NULL) {
    set_has_long_();
  } else {
    clear_has_long_();
  }
  long__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), long_);
  // @@protoc_insertion_point(field_set_allocated:target_cam.target_data.long)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace target_cam

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_camdata_2eproto
